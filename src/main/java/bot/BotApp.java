package bot;

import bot.ai.OpenAiHelper;
import bot.config.ServerConfig;
import bot.config.Config;
import discord4j.common.util.Snowflake;
import discord4j.core.DiscordClient;
import discord4j.core.GatewayDiscordClient;
import discord4j.core.event.domain.lifecycle.ReadyEvent;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.User;
import discord4j.core.object.entity.channel.Channel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.EnumSet;

public class BotApp {
    // Log4j logging
    private static final Logger logger = LoggerFactory.getLogger(BotApp.class);

    // Application configuration from properties file
    private static Config config;

    // Helper class that utilizes openai-java
    private static OpenAiHelper aiHelper;

    public static void main(String[] args) {
        // Load application configuration
         config = Config.getInstance();
         aiHelper = OpenAiHelper.getInstance();

        // Connect to discord
        var client = DiscordClient.create(config.getBotToken());
        Mono<Void> login = client.withGateway((GatewayDiscordClient gateway) ->  {

            // Login event
            Mono<Void> onLogin = gateway.on(ReadyEvent.class, event ->
                    Mono.fromRunnable(() -> {
                        final User self = event.getSelf();
                        logger.info("Logged in as {}:{}", self.getUsername(), self.getDiscriminator());
                    })).then();

            // User sends message to channel
            Mono<Void> onMessage = gateway.on(MessageCreateEvent.class, event -> {
                // check message for command, and respond
                Message message = event.getMessage();
                Snowflake serverId = event.getGuildId().orElseGet(message::getChannelId);
                Config.addServerConfig(serverId);
                ServerConfig serverConfig = Config.getServerConfig(serverId);
                logger.debug("Discord message content: {}", message.getContent());

                // Channel Object
                Channel messageChannel = message.getChannel().block();

                // Is Private message
                boolean isPrivate = messageChannel != null && messageChannel.getType() == Channel.Type.DM;
                long authorId = message.getAuthor().map(user -> user.getId().asLong()).orElse(0L);
                long botId = gateway.getSelfId().asLong();

                // Verify valid command character used, and take action based on valid commands
                if (message.getContent().charAt(0) == config.getCommandCharacter()
                        || message.getContent().charAt(0) == '/'
                        || (isPrivate && botId != authorId)) {
                    String query = parseQuery(message.getContent());
                    String command = parseCommand(message.getContent());
                    switch (command) {
                        case "gpt":
                            String response = "";
                            if (OpenAiHelper.isChatModel(config.getOpenAiModel())) {
                                response = aiHelper.makeOpenAiChatCompletionRequest(query, serverConfig);
                            } else if(OpenAiHelper.isCompletionModel(config.getOpenAiModel())) {
                                response = aiHelper.makeOpenAiCompletionRequest(query, serverConfig);
                            }
                            if (response.isEmpty() || response.isBlank()) {
                               response = "A valid response was not generated by OpenAI, " +
                                       "consider trying again or providing more details";
                            }
                            String finalResponse = response;
                            return message.getChannel().flatMap(channel -> channel.createMessage(finalResponse));
                        case "gptrand":
                            double randomness = parseRandomnessValue(query);
                            Config.getServerConfig(serverId).setOpenAiTemperature(randomness);
                            final String result = "Randomness was set to " + randomness;
                            return message.getChannel().flatMap(channel -> channel.createMessage(result));
                        case "gptmodel":
                            String model = parseModelValue(query);
                            Config.getServerConfig(serverId).setOpenAiModel(model);
                            final String modelResult = "Model was set to " + model;
                            return message.getChannel().flatMap(channel -> channel.createMessage(modelResult));
                        case "gptconfig":
                            final String configResult= "Current Configuration:\n"
                                    + Config.getServerConfigString(serverId);
                            return message.getChannel().flatMap(channel -> channel.createMessage(configResult));
                        case "gpthelp":
                            return message.getChannel().flatMap(channel -> channel.createMessage(getHelpText()));
                        case "gptimage":
                            String imageResult = aiHelper.makeOpenAiImageRequest(query);
                            return message.getChannel().flatMap(channel -> channel.createMessage(imageResult));
                        case "gptrole":
                            OpenAiHelper.updateRole(query, serverConfig);
                            serverConfig.setBotPersonality(query);
                            break;
                        default:
                            if (isPrivate) {
                                response = "";
                                if (OpenAiHelper.isChatModel(config.getOpenAiModel())) {
                                    response = aiHelper.makeOpenAiChatCompletionRequest(query, serverConfig);
                                } else if(OpenAiHelper.isCompletionModel(config.getOpenAiModel())) {
                                    response = aiHelper.makeOpenAiCompletionRequest(query, serverConfig);
                                }
                                if (response.isEmpty() || response.isBlank()) {
                                    response = "A valid response was not generated by OpenAI, " +
                                            "consider trying again or providing more details";
                                }
                                finalResponse = response;
                                return message.getChannel().flatMap(channel -> channel.createMessage(finalResponse));
                            }
                            break;
                    }
                }
                return Mono.empty();
            }).then();

            return onLogin.and(onMessage);
        });

        login.block();
    }

    /**
     * Get help text for discord bot
     *
     * @return bot help text with command list
     */
    public static String getHelpText() {
        String text = "GPT Bot interfaces with openAi gpt-4, to deliver interesting chats with a powerful AI.\n\n";
        text += "both `!` and `/` characters can be used to issue commands to the bot.\n";
        text += "\t`!gpt`       Send a message to gpt, and get a text based reply\n";
        text += "\t`!gptImage`  Send a message to gpt, and get an image as a response\n";
        text += "\t`!gptRand`   Changes the randomness of the response 0.0-1.0\n";
        text += "\t`!gptModel`  Changes the openAi Model used\n";
        text += "\t`!gptConfig` Shows current GPT Bot configuration\n";
        text += "\t`!gptHelp`   Generates list off commands\n";
        text += "\t`!gptrole`   define a role for the bot this will affect its personality";
        return text;
    }

    /**
     * Return valid openAi Model from user message
     *
     * @param message discord channel message
     * @return openAi model from channel message
     */
    public static String parseModelValue(String message) {
        String modelConfig = config.getOpenAiModel();
        for(OpenAiHelper.OpenAiModels value: new ArrayList<>
                (EnumSet.allOf(OpenAiHelper.OpenAiModels.class))) {
            if (message.contains(value.getId())) {
                modelConfig = value.getId();
                break;
            }
        }

        return modelConfig;
    }

    /**
     * Get valid temperature value from user message
     *
     * @param message discord channel message
     * @return openAi temperature value
     */
    public static double parseRandomnessValue(String message) {
        double temperature;

        message = message.replaceAll("[^\\d.]", "");
        try {
            temperature = Double.parseDouble(message);
            if(!(temperature <= 2.0) || !(temperature > 0)) {
                temperature = 0.7;
            }
        } catch(Exception e) {
            temperature = 0.7;
        }
        return temperature;
    }

    /**
     * get command string from user message
     * @param message discord channel message
     * @return bot command from user message
     */
    public static String parseCommand(String message) {
        StringBuilder command = new StringBuilder();
        for (int i = 1; i < message.length(); i++) {
            if(Character.isWhitespace(message.charAt(i))) {
                break;
            } else {
                command.append(message.charAt(i));
            }
        }

        return command.toString().toLowerCase();
    }

    /**
     * get user query
     * @param message  discord channel message
     * @return text occurring after command text
     */
    public static String parseQuery(String message) {
        int queryStartIndex = 0;
        for (int i = 1; i < message.length(); i++) {
            if (Character.isWhitespace(message.charAt(i))) {
                queryStartIndex= i + 1;
                break;
            }
        }

        return message.substring(queryStartIndex);
    }
}
